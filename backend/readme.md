## package.json 相關資訊

如同先前於 `week-02/readme.md` 所提到的，`package.json` 主要紀錄了專案中的各種基本資訊，例如名稱、版本、作者等，另外最常會接觸到的是下載套件的版本紀錄以及 `scripts` 區塊的指令編輯，從 `package.json` 我們可以快速掌握該專案的一些訊息以及使用的一些技術、套件為何。

### scripts 定義指令

在 `package.json` 中，存在一個 `scripts` 可以讓我們自行定義常用的指令動作，將其縮寫為簡單的名稱以方便我們重複的呼叫，例如我們可以定義：

```json
{
  "scripts": {
    "start": "node app.js"
  }
}
```

就可以透過執行 `npm start` 來啟動 server (一般需要加上 `run` 來執行，如 `npm run dev`，但使用 `start` 關鍵字則不需)，這對於當指令動作需要帶上多個參數時或是要連續執行多個指令 (使用 `&&` 做連接) 而言相對方便許多。

### 套件版本紀錄

透過 npm 下載的套件會被記錄到 `package.json` 中底下的區塊，其中又分為 `dependencies` 和 `devDependencies` 兩部分，兩者的差異在於 dependencies 主要記錄那些實際在正式環境中會使用到的套件，通常也是較為核心的套件 (例如本專案中的 express 即為伺服器所需的核心套件)，而 devDependencies 則記錄一些在開發過程中的輔助套件，通常是一些預處理器、程式碼檢驗的工具 (例如 postcss、typescript 相關套件、eslint 等)。

另外關於版本的紀錄，可以觀察到大部分都帶有 `^` 或是 `~` 的前綴，一般而言大部分的流通套件版本都會遵守 [semantic versioning](https://semver.org/) 的原則，即為

```
Version x(主版號).x(副版號).x(補丁號)
```

更新的規模由左至右會越來越小，且理論上在同一個主版號下新的版本應該是要可以向下兼容舊版本的。

而 `^`、`~` 這兩個符號就代表對版號的限制：

- `^`：限制到**主版號**，例如 `^18.3.2` 代表 `>=18.3.2` 且 `<19.0.0`。
- `~`：限制到**副版號**，例如 `~18.3.2` 代表 `>=18.3.2` 且 `<18.4.0`。

這也是 npm 和 yarn 先前的差異點之一，由於 yarn 會直接紀錄套件的確切版本來統一版本的管理，但後續 npm 也支援了 `package-lock.json` 來達到類似的效果，從該檔案中也可以觀察到一個大套件所依賴的其他小套件的詳細資訊 (例如 express 即依賴了許多和網路伺服器相關的套件)。

## 設定環境變數

有時候我們想要在不更動主程式的情況下，以較有彈性的方式來調整一些環境的參數 (例如 port number)，又或者是需要帶入一些機敏的訊息 (如資料庫或其他帳號、密碼等)，此時就可以利用環境設定檔的方式來將這些資訊傳入給主程式做使用，本次所採用的是在 Node.js 環境中常見的 `dotenv` 套件來引入環境變數的設定。

透過 `npm install dotenv` 將套件安裝後，在 `backend` 裡新增 `.env` 檔案來記錄我們所需要的變數：

```dosini
# .env

PORT=3001
```

另外再新增一個 `.gitignore` 並將 `.env` 紀錄在裡面，由於在環境設定檔中可能會放入一些帳號、密碼的資訊，因此在此處必須將其隱藏以避免將重要的資訊公布出去。而關於選擇是否隱藏檔案的標準，我認為大致上可以從三個面向去衡量：

1. 隱私、安全性

   例如上述提到的環境設定，或是任何可能會洩漏個人隱私、敏感資訊的內容都不應該被放到雲端平台上。

2. 可重複獲取

   最常見的如 `node_modules` 資料夾，因為套件的內容都可以透過 `package.json` 的紀錄來重新下載取得，因此就不需要將大量的套件內容上傳以減少專案的體積。

3. 正式環境需求

   在開發過程中我們可能會運用到許多測試或是協助開發的工具，會產生一些只有在本地開發才需要的檔案，在正式環境中並沒有被使用到的需求，那麼這些檔案也可以被排除在版本控制之外 (例如使用 `.test`、`.local` 結尾來命名檔案，在 `.gitignore` 中就可以使用 `*.test`、`*.local` 來一次排除)。

完成上述的流程後，最後在 `app.js` 裡將環境變數導入進來：

```js
// app.js

require("dotenv").config();
// 先讀取環境變數中的 port number，若讀取不到則使用預設值 3000
const port = process.env.PORT || 3000;
```

開啟 `localhost:3001` 便可以看到對應的畫面出現，此處的 localhost 是一種特別的網路協定，代表回歸到本地環境的域名，通常會對到 IPv4 127.0.0.1 的網域，透過向自己本身發出請求，再搭配端口號碼 (如 127.0.0.1:3001) ，在不連接網路的情況下也可以開啟對應的伺服器。

除此之外我們也可以在終端機裡使用 `curl` 指令來測試網路連線，而 `curl` 是一個 Linux 的指令，用於在終端機裡進行網頁內容的取得或是 api endpoints 的測試，基本的指令組合為：

```shell
$ curl <參數> <網址>
```

單純輸入網址而不帶參數的話即是基本的對該網域發出請求，並能獲取該網頁所回傳的內容，另外也可以加上以下參數來調整不同的設定：

- `-o <檔名>/-O`：下載網頁中的檔案。
- `-C`：若下載的過程中被中斷，可以從中斷的地方繼續下載。
- `-L`：針對部分會進行 301/302 轉址的網站進行跟隨追蹤，而不是直接回應 301/302 的內容。

至於 api endpoints 的測試，也有一系列的參數來輔助，常見的如下：

- `-X <method>`：指定 http 請求的方法類型，如 GET、POST、PUT... 等。
- `-H`：設定請求中的 header 欄位。
- `-d`：在 POST 方法中設定所要帶上的 request data。
- `-v`：增加輸出的訊息以方便進行除錯。
- `-u`：帶上使用者的帳號、密碼。
- `-b`：設定所要帶上的 cookie。

例如 ：

```
$ curl -X POST -H "Content-Type: application/json" -d '{"id": 1, "name": "Andrew"}' http://www.test.com/api
```

## CJS v.s. ESM

在本次的範例程式碼中是使用 CJS 的方法，透過 `require` 來引入想要的套件、模組，在導出模組的時候則會使用 `module.export` 來達成，至於另一派 ESM 的方法則是使用 `import`、`export` 等關鍵字來執行。兩者的差異除了上述的語法上的不同之外還有：

1. 加載時間

   ESM 所採用的是靜態加載，也就是在程式碼編譯的階段時就已經處理完模組之間的關係，而 CJS 則是使用動態加載的方式，在程式執行的時候才根據需要來加載模組。且 ESM 為非同步的載入方式，相較於同步載入的 CJS 不需等待模組載入完成後才繼續解析後面的內容。

2. 執行環境

   CJS 主要用於 Node.js 的環境，而 ESM 除了 Node.js 以外也可以在瀏覽器底下直接運行。

3. 預設導出

   ESM 支援 `export default` 預設導出模組的選項，可以簡化模組的導出設計。

以目前的環境來說，由於靜態加載的優勢，可以更有效率的載入模組以提高性能，ESM 是較為主流的選項，且後續若導入 TypeScript 系統時其語法的設計也較接近 ESM 的風格。
